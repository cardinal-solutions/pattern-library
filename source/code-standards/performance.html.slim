---
title: Performance
id: 'code-standards'
---
h1 Performance

p When building modern websites, performance is a real design and development constraint and must be taken into account at every level of the development process. The reason it is a design and development constraint is fairly simple: with the explosion of an everything-connected world and the rise of the mobile-only user, the chances that a site is going to be viewed primarily by someone sitting at a workstation with a high speed internet connection diminishes daily. This constraint isn't new either; way back in 2006, Amazon reported that a 100ms delay cost them 1% of sales. This was before the great reach of broadband took hold and before the current mobile computing boom came full swing, which have only lessened the patience of consumers. As Compuware reports, 75% of mobile web users expect a site to load as fast or faster on their mobile devices as they do their desktop computers, with 60% of mobile web users leaving a site and not coming back if it takes more than 3 seconds to load, with 78% of users trying only one more time. Moreover, if a user abandons a mobile site, 33% will go to a competitor's site. What all this means is that performance affects website revenue. Google, helpfully, provides some interesting insight into how performance could have affected their 2011 revenue:

ul
  li Google made approximately $18.8 Million per day on search advertising.
  li A 400ms delay (less than half of a second) reduces average number of daily searches by 0.59% (and is about twice their warning threshold)
  li That amounts to a daily loss of $111,000, or about $40.5 Million a year

p When discussing and testing performance, it is important to do both with an eye toward mobile. This means that all performance testing needs to take place on actual devices, not just emulations, and on actual networks. Many of the standards have some wiggle room, but presented are the ideals and maximums for performance standards. The ideals and maximums have been chosen with an eye towards the realities of a media heavy site, including the realities of advertising and heavy multimedia usage. As 80% of the end-user response time is spent on the front-end, most of the performance suggestions are front-end based.

section.styleguide-module-details
  h2 Testing and Grading Performance

  p In addition to the below, sites should be able to hit and maintain certain performance benchmarks from a variety of different resources across the internet. These systems are a good way of doing easy tests of a site to determine how they stack up. The following are good testing and grading resources, and the minimum target scores for each resource:

  ul
    li Page Speed - 85
    li Web Page Test
    li First Byte Time: 85
    li Use persistent connection: 85
    li Use gzip compression for transferring compressable responses: 90
    li Compress Images: 90
    li Use Progressive JPEGs: 90
    li Leverage browser caching of static assets: 90
    li Use a CDN for all static assets: 85
    li YSlow - 85
    li Payload Performance

  p Load times, load sizes, and number of requests are extraordinarily important and often overlooked or left to the end of a development cycle to start to optimize. Ideal statistics are presented first, with maximums presented second that should only be broached under edge circumstances. It is always best to keep actual performance as much under these numbers as possible.

  ul
    li Time To First Byte: 200ms - 350ms
    li DOM Content Loaded: 1000ms - 2000ms
    li JS Load Event Fired: 900ms - 2200ms
    li Total Download Size: 1MB - 2MB
    li DNS Lookup: 10ms - 20ms
    li HTTP Requests: 50 - 75
    li Page Performance

  p Once a site has been downloaded, performance of the user interactions is important as well. The goal to reach for is a site running at or above 60 frames per second. Anything below this makes sites appear poorly built, sluggish, and unresponsive. When dealing with user input, interactions should be under 100ms to feel instant and under 250ms to feel fast. Anything longer and interactions begin to feel sluggish. Some good rules of thumb to avoid the user interface from feeling this way are:

  ul
    li Do not bind expensive processes to document/window events (scroll, resize, etcâ€¦)
    li Use CSS3 translate instead of absolute position with top and left properties
    li Do not emulate fixed positioning using JavaScript
    li Animate through CSS3 instead of JavaScript
    li Group JavaScript document reads and writes separately. Use requestAnimationFrame to reduce layout thrashing when reading and  li writing to the DOM
    li Avoid Internet Explorer's CSS expression selectors
    li Front End Optimizations

  p There are a number of optimization techniques that can be employed in order to enhance overall performance on a site. Some of these are battle-hardened optimizations that should be employed on all sites, while others are more experimental. As such, they will be divided into categories based on which are most critical for success, and which can be played with.


section.styleguide-module-details
  h2 Critical Optimizations

  ul
    li Avoid page redirects
    li Provide proper headers for all files
    li Static files (fonts, js, css) should have sufficiently long cache, at least 30 days
    li Images should have a slightly shorter cache, at least 15 days
    li HTML should have a short cache, around 15 minutes
    li Internet Explorer Edge header should always be passed
    li All JavaScript should be moved to the footer
    li document.write should be avoided
    li Images with no transparency should be served as progressive JPEGs, not as PNG files
    li CSS and JavaScript should be minified and aggregated
    li Reduce all blocking in the critical path to only page HTML and CSS
    li Do not group CSS by media in <link> tags; all of the CSS gets downloaded anyway. Instead, reduce the number of aggregates     li and wrap internal CSS in media queries.
    li Use a CDN
    li Cache page requests
    li Utilize progressive enhancement with feature detection to serve only what is needed to a user
    li Ensure that files that are only useful on particular pages only load on those pages, not all pages
    li Always load CSS before JavaScript
    li Recommended Optimizations

  ul
    li Lazy load non-critical content. See Filament Group's Ajax-Include Pattern
    li Employ a Responsive Image solution. Until a standard exists, look for one based on image width over viewport size.
    li ASYNC and DEFER all on-page scripts (for instance, DART tags). See $script.js for a light weight async JavaScript loader
    li ASYNC all ads
    li When utilizing a CDN such as Akami, use it to serve scripts such as jQuery instead of Google's CDN as it will be faster    on a li cold cache
    li Inline small but important files (generally <3Kb) to reduce HTTP requests. Aggregate other small files to reduce HTTP li requests

section.styleguide-module-details
  h2 Experimental Optimizations

  ul
    li Inline above-the-fold CSS into the HTML. Push additional CSS to the footer
    li Utilize .webp and .webm file formats
    li Employ the spdy protocol
    li Dynamically serve appropriately sized images from server side instead of relying upon a client side technique
