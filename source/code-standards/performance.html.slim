---
title: Performance
id: 'code-standards'
---

section.styleguide-module-details

  h1 Performance

  p When building modern websites, performance is a real design and development constraint and must be taken into account at every level of the development process.

  p The reason it is a design and development constraint is fairly simple: with the explosion of an everything-connected world and the rise of the mobile-only user, the chances that a site is going to be viewed primarily by someone sitting at a workstation with a high speed internet connection diminishes daily.

  p This constraint isn't new either; way back in 2006, Amazon reported that a 100ms delay cost them 1% of sales. This was before the great reach of broadband took hold and before the current mobile computing boom arrived, which have only lessened the patience of consumers.

  p As Compuware reports, 75% of mobile web users expect a site to load as fast or faster on their mobile devices than they do on their desktop computers and with:

    ul
      li 60% of mobile web users leaving a site and not coming back if it takes more than 3 seconds to load
      li 78% of users trying only one more time
      li 33% of those who give up will go to a competitor's site

  p What all this means is that performance affects website revenue. Google, helpfully, provides some interesting insight into how performance could have affected their 2011 revenue:

  ul
    li Google made approximately $18.8 Million per day on search advertising
    li A 400ms delay (less than half of a second) reduces average number of daily searches by 0.59% (and is about twice their warning threshold)
    li That amounts to a daily loss of $111,000, or about $40.5 Million a year

  p When discussing and testing performance, it is important to do both with an eye toward mobile.

  p This means that all performance testing needs to take place on <strong>actual devices</strong>, not just emulators, and on <strong>actual networks</strong>. Many of the standards have some wiggle room, and are presented as the ideals and maximums for performance standards.

  p These ideals and maximums have been chosen with an eye towards the realities of a media heavy site, including the realities of advertising and heavy multimedia usage.

  p As 80% of the end-user response time is spent on the front-end, most of the performance suggestions are front-end based.

section.styleguide-module-details

  h2 Testing and Grading Performance

  p In addition to the below, sites should be able to hit and maintain certain performance benchmarks from a variety of different resources across the internet. These systems are a good way of doing easy tests of a site to determine how they stack up. The following are good testing and grading resources, and the minimum target scores for each resource:

  ul
    li Page Speed - 85
    li Web Page Test
      ul
        li First Byte Time: 85
        li Use persistent connection: 85
        li Use gzip compression for transferring compressable responses: 90
        li Compress Images: 90
        li Use Progressive JPEGs: 90
        li Leverage browser caching of static assets: 90
        li Use a CDN for all static assets: 85
        li YSlow - 85

  h4 Payload Performance

  p Load times, load sizes, and number of requests are extraordinarily important and often overlooked or left to the end of a development cycle to start to optimize. Ideal statistics are presented first, with maximums presented second that should only be broached under edge circumstances.

  p It is always best to keep actual performance as far below these thresholds as possible.

  ul
    li Time To First Byte: 200ms - 350ms
    li DOM Content Loaded: 1000ms - 2000ms
    li JS Load Event Fired: 900ms - 2200ms
    li Total Download Size: 1MB - 2MB
    li DNS Lookup: 10ms - 20ms
    li HTTP Requests: 50 - 75

  h4 Page Performance

  p Once a site has been downloaded, performance of the user interactions is important as well.

  p The goal to reach for is a site running at or above 60 frames per second. Anything below this makes sites appear poorly built, sluggish, and unresponsive.

  p When dealing with user input, interactions should be under 100ms to feel instant and under 250ms to feel fast. Anything longer and interactions begin to feel sluggish. Some good rules of thumb to prevent the user interface from feeling this way are:

  ul
    li Do not bind expensive processes to document/window events (scroll, resize, etcâ€¦); if you do, use throttling, rate-limiting, or debouncing
    li Use CSS3 translate instead of absolute position with top and left properties
    li Do not emulate fixed positioning using JavaScript
    li Animate through CSS3 instead of JavaScript
    li Group JavaScript document reads and writes separately
    li Use requestAnimationFrame to reduce layout thrashing when reading and writing to the DOM
    li Avoid Internet Explorer's CSS expression selectors

section.styleguide-module-details

  h2 Front-End Optimizations

  p There are a number of optimization techniques that can be employed in order to enhance the overall performance of a site. Some of these are battle-hardened optimizations that should be employed on all sites, while others are more experimental. As such, they will be divided into categories based on which are most critical for success, and which can be played with.

  h4 Critical Optimizations

  ul
    li Avoid page redirects
    li Provide proper headers for all files
    li Static files (fonts, js, css) should have sufficiently long cache, at least 30 days
    li Images should have a slightly shorter cache, at least 15 days
    li HTML should have a short cache, around 15 minutes
    li Internet Explorer Edge header should always be passed
    li All JavaScript should be moved to the footer; except in the case of some utilities like Modernizr
    li document.write should be avoided
    li Images with no transparency should be served as progressive JPEGs, not as PNG files
    li CSS and JavaScript should be minified and aggregated
    li Reduce all blocking in the critical path to only page HTML and CSS
    li Do not group CSS by media in <link> tags; all of the CSS gets downloaded anyway. Instead, reduce the number of aggregates and wrap internal CSS in media queries
    li Use a CDN
    li Cache page requests
    li Utilize progressive enhancement with feature detection to serve only what is needed to a user
    li Ensure that files that are only useful on particular pages only load on those pages, not all pages
    li Always load CSS before JavaScript
    li Serve gzipped versions of assets when possible; this will rely on server configuration

  h4 Recommended Optimizations

  ul
    li Lazy load non-critical content. See <a href="https://github.com/filamentgroup/Ajax-Include-Pattern/">Filament Group's Ajax-Include Pattern</a>
    li Employ a Responsive Image solution like <a href="https://github.com/scottjehl/picturefill">Picturefill</a>; until a standard exists, look for one based on image width over viewport size
    li ASYNC and DEFER all on-page scripts (for instance: DART tags); see <a href="http://www.dustindiaz.com/scriptjs">$script.js</a> for a light weight async JavaScript loader
    li ASYNC all ads
    li When utilizing a CDN such as Akami, use it to serve scripts such as jQuery instead of Google's CDN as it will be faster on a cold cache
    li Inline small but important files (generally <3Kb) to reduce HTTP requests. Aggregate other small files to reduce HTTP requests

  h4 Experimental Optimizations

  ul
    li Inline above-the-fold CSS into the HTML using something like <a href="https://github.com/addyosmani/critical">Critical</a>; push additional CSS to the footer
    li Utilize .webp and .webm file formats
    li Employ the SPDY protocol
    li Dynamically serve appropriately sized images from server side instead of relying upon a client side technique
